<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      three.js webgl - additive animation -
      skinning
    </title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link
      type="text/css"
      rel="stylesheet"
      href="main.css"
    />
    <style>
      a {
        color: blue;
      }
      .control-inactive button {
        color: #888;
      }

      .select_file {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1000;
        background-color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        color: black;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <div class="select_file">
      GLTF:
      <input type="file" id="gltf" />
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.145.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/",
          "three/src/": "https://unpkg.com/three@0.145.0/src/"
        }
      }
    </script>

    <script src="./dist/dev/mtx-poll-three-js.js"></script>

    <script type="module">
      import {
        Vector3,
        Euler,
        Quaternion,
      } from "three";
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FirstPersonControls } from "three/addons/controls/FirstPersonControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

      const clock = new THREE.Clock();
      let first_person_controls;
      let controls;

      let animation_state = {
        animations: [],
      };

      let logger = false;

      const i = 200; // Polling interval
      const s = new Vector3();
      const camera_rotation_e = new Euler();
      const q = new Quaternion();

      const CreateLogger = (object3D, appKey) => {
        if (logger) return;

        let data = {
          pollInterval: panelSettings.updateSpeed,
          apiVersion: "v2",
          userMeta: {
            sceneName: "Scene name",
            gameLocation: "Game location name",
            params: {
              additionalField:
                "Any additional information",
              // more fields ...
            },
          },
        };

        logger = new MetalitixLogger(
          panelSettings.ApiKey,
          data
        );

        logger.startSession(object3D);
        animation_state.animations = [];
      };

      let scene, renderer, camera, stats;
      let model, skeleton, mixer;
      let panelSettings,
        numAnimations,
        currentAction,
        GLTF;

      const crossFadeControls = [];

      let currentBaseAction = "";
      const allActions = [];
      const baseActions = {};

      init();

      function init() {
        const container =
          document.getElementById("container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(
          0xa0a0a0
        );
        scene.fog = new THREE.Fog(
          0xa0a0a0,
          10,
          50
        );

        const hemiLight =
          new THREE.HemisphereLight(
            0xffffff,
            0x444444
          );
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight =
          new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(3, 10, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 2;
        dirLight.shadow.camera.bottom = -2;
        dirLight.shadow.camera.left = -2;
        dirLight.shadow.camera.right = 2;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 100;
        scene.add(dirLight);

        // ground

        const mesh = new THREE.Mesh(
          new THREE.PlaneGeometry(100, 100),
          new THREE.MeshPhongMaterial({
            color: 0x999999,
            depthWrite: false,
          })
        );
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);

        const loader = new GLTFLoader();

        document
          .getElementById("gltf")
          .addEventListener("change", (e) => {
            let url = URL.createObjectURL(
              e.target.files[0]
            );
            loader.load(url, setUpObject);
            document.querySelector(
              ".select_file"
            ).style.display = "none";
          });

        function setUpObject(gltf) {
          model = gltf.scene;
          GLTF = gltf;
          scene.add(model);
          if (GLTF.animations.length)
            currentBaseAction =
              gltf.animations[0].name;

          gltf.animations.forEach((anim, i) => {
            baseActions[anim.name] = {
              weight: i == 0 ? 1 : 0,
            };
          });

          model.traverse(function (object) {
            if (object.isMesh)
              object.castShadow = true;
          });

          skeleton = new THREE.SkeletonHelper(
            model
          );
          skeleton.visible = false;
          scene.add(skeleton);

          const animations = gltf.animations;
          mixer = new THREE.AnimationMixer(model);

          numAnimations = animations.length;

          for (
            let i = 0;
            i !== numAnimations;
            ++i
          ) {
            let clip = animations[i];
            const name = clip.name;

            if (baseActions[name]) {
              const action =
                mixer.clipAction(clip);
              activateAction(action);
              baseActions[name].action = action;
              allActions.push(action);
            }
          }

          createPanel();

          animate();
        }

        renderer = new THREE.WebGLRenderer({
          antialias: true,
        });
        renderer.setPixelRatio(
          window.devicePixelRatio
        );
        renderer.setSize(
          window.innerWidth,
          window.innerHeight
        );
        renderer.outputEncoding =
          THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        container.appendChild(
          renderer.domElement
        );

        // camera
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          100
        );
        camera.position.set(-1, 2, 3);

        // Orbit

        controls = new OrbitControls(
          camera,
          renderer.domElement
        );
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.target.set(0, 1, 0);
        controls.update();

        /// Fly

        first_person_controls =
          new FirstPersonControls(
            camera,
            renderer.domElement
          );

        first_person_controls.movementSpeed = 10;
        first_person_controls.domElement =
          renderer.domElement;
        first_person_controls.lookSpeed = 0.1;
        first_person_controls.enabled = false;

        stats = new Stats();
        container.appendChild(stats.dom);

        window.addEventListener(
          "resize",
          onWindowResize
        );
      }

      function createPanel() {
        const panel = new GUI({ width: 310 });

        const folder2 =
          panel.addFolder("LoggerData");
        const folder1 = panel.addFolder(
          "Base Actions"
        );
        const folder4 = panel.addFolder("Camera");

        panelSettings = {
          "modify time scale": 1.0,
          ApiKey: "",
          updateSpeed: 500,
          Loop: true,
          "Show camera vectors & positions": false,
          "Camera controls": "Orbit",
        };

        const baseNames = [
          "None",
          ...Object.keys(baseActions),
        ];

        folder1
          .add(
            panelSettings,
            "modify time scale",
            0.0,
            5,
            0.01
          )
          .onChange(modifyTimeScale);

        if (
          GLTF.animations &&
          GLTF.animations.length
        )
          for (
            let i = 0, l = baseNames.length;
            i !== l;
            ++i
          ) {
            const name = baseNames[i];
            const settings = baseActions[name];
            panelSettings[name] = function () {
              const currentSettings =
                baseActions[currentBaseAction];
              let start = currentSettings
                ? currentSettings.action
                : null;
              currentAction = settings
                ? settings.action
                : null;

              if (start !== currentAction) {
                prepareCrossFade(
                  start,
                  currentAction,
                  0.35
                );
              }
            };

            window.requestAnimationFrame(() => {
              if (i === 0) panelSettings[name]();
            });

            crossFadeControls.push(
              folder1
                .add(panelSettings, name)
                .name(name.substr(0, 21))
            );

            if (name != "None") {
              panelSettings[name + " time"] = 0;
              let controller = folder1
                .add(
                  panelSettings,
                  name + " time",
                  0,
                  1,
                  0.01
                )
                .name(
                  ("Time: " + name).substr(0, 15)
                );

              controller.onChange((e) => {
                if (
                  currentAction &&
                  currentAction.getClip().name ==
                    name
                ) {
                  currentAction.time =
                    e *
                    currentAction.getClip()
                      .duration;
                  panelSettings[name + " time"] =
                    e;
                }
              });

              let check = () => {
                controller.updateDisplay();

                window.requestAnimationFrame(
                  check
                );
              };

              check();
            }
          }

        let api_controller = folder2
          .add(panelSettings, "ApiKey")
          .onChange((value) => {
            CreateLogger(camera, value);
          });
        folder2
          .add(
            panelSettings,
            "updateSpeed",
            100,
            5000
          )
          .name("Update speed (ms)");
        folder2
          .add(panelSettings, "Loop")
          .name("Is animation loop on");
        folder4.add(
          panelSettings,
          "Show camera vectors & positions"
        );
        folder4
          .add(panelSettings, "Camera controls", [
            "Orbit",
            "Mouse",
          ])
          .onChange((value) => {
            if (
              controls &&
              first_person_controls &&
              value == "Orbit"
            ) {
              controls.enabled = true;
              first_person_controls.enabled = false;
            }

            if (
              controls &&
              first_person_controls &&
              value == "Mouse"
            ) {
              controls.enabled = false;
              first_person_controls.enabled = true;
            }
          });

        // for ( const name of Object.keys( additiveActions ) ) {

        // 	const settings = additiveActions[ name ];

        // 	panelSettings[ name ] = settings.weight;
        // 	folder2.add( panelSettings, name, 0.0, 1.0, 0.01 ).listen().onChange( function ( weight ) {

        // 		setWeight( settings.action, weight );
        // 		settings.weight = weight;

        // 	} );

        // }

        folder1.open();
        // folder2.open();

        crossFadeControls.forEach(function (
          control
        ) {
          control.setInactive = function () {
            control.domElement.classList.add(
              "control-inactive"
            );
          };

          control.setActive = function () {
            control.domElement.classList.remove(
              "control-inactive"
            );
          };

          const settings =
            baseActions[control.property];

          if (!settings || !settings.weight) {
            control.setInactive();
          }
        });
      }

      function activateAction(action) {
        const clip = action.getClip();
        const settings = baseActions[clip.name];
        setWeight(action, settings.weight);
        action.play();
      }

      function modifyTimeScale(speed) {
        mixer.timeScale = speed;
      }

      function prepareCrossFade(
        startAction,
        endAction,
        duration
      ) {
        // If the current action is 'idle', execute the crossfade immediately;
        // else wait until the current action has finished its current loop

        if (
          (GLTF &&
            currentBaseAction ===
              GLTF.animations[0].name) ||
          !startAction ||
          !endAction
        ) {
          executeCrossFade(
            startAction,
            endAction,
            duration
          );
        } else {
          synchronizeCrossFade(
            startAction,
            endAction,
            duration
          );
        }

        // Update control colors

        if (endAction) {
          const clip = endAction.getClip();
          currentBaseAction = clip.name;
        } else {
          currentBaseAction = "None";
        }

        crossFadeControls.forEach(function (
          control
        ) {
          const name = control.property;

          if (name === currentBaseAction) {
            control.setActive();
          } else {
            control.setInactive();
          }
        });
      }

      function synchronizeCrossFade(
        startAction,
        endAction,
        duration
      ) {
        mixer.addEventListener(
          "loop",
          onLoopFinished
        );

        function onLoopFinished(event) {
          if (event.action === startAction) {
            mixer.removeEventListener(
              "loop",
              onLoopFinished
            );

            executeCrossFade(
              startAction,
              endAction,
              duration
            );
          }
        }
      }

      function executeCrossFade(
        startAction,
        endAction,
        duration
      ) {
        // Not only the start action, but also the end action must get a weight of 1 before fading
        // (concerning the start action this is already guaranteed in this place)

        if (endAction) {
          setWeight(endAction, 1);
          endAction.time = 0;

          if (startAction) {
            // Crossfade with warping

            startAction.crossFadeTo(
              endAction,
              duration,
              true
            );
          } else {
            // Fade in

            endAction.fadeIn(duration);
          }
        } else {
          // Fade out

          startAction.fadeOut(duration);
        }
      }

      // This function is needed, since animationAction.crossFadeTo() disables its start action and sets
      // the start action's timeScale to ((start animation's duration) / (end animation's duration))

      function setWeight(action, weight) {
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(weight);
      }

      function onWindowResize() {
        camera.aspect =
          window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(
          window.innerWidth,
          window.innerHeight
        );
      }

      function animate() {
        if (
          first_person_controls &&
          first_person_controls.enabled
        )
          first_person_controls.update(
            clock.getDelta()
          );
        // Render loop

        if (
          panelSettings[
            "Show camera vectors & positions"
          ]
        ) {
          camera.updateProjectionMatrix();
          camera.getWorldPosition(s);
          camera.getWorldQuaternion(q);
          camera_rotation_e.setFromQuaternion(q);

          const dir = new THREE.Vector3(
            0,
            0,
            -1
          ).applyEuler(
            new THREE.Euler(camera_rotation_e.x, camera_rotation_e.y, camera_rotation_e.z)
          );
          // dir.applyEuler()

          //normalize the direction vector (convert to vector of length 1)
          dir.normalize();

          const origin = s;
          const length = 0.5;
          const hex = 0xff0000;

          const arrowHelper =
            new THREE.ArrowHelper(
              dir,
              origin,
              length,
              hex
            );
          scene.add(arrowHelper);
        }

        requestAnimationFrame(animate);

        for (
          let i = 0;
          i !== numAnimations;
          ++i
        ) {
          const action = allActions[i];
          const clip = action.getClip();
          const settings = baseActions[clip.name];
          settings.weight =
            action.getEffectiveWeight();
        }

        // Get the time elapsed since the last frame, used for mixer update

        const mixerUpdateDelta = clock.getDelta();

        // Update the animation mixer, the stats panel, and render this frame

        mixer.update(mixerUpdateDelta);

        if (currentAction) {
          panelSettings[
            currentAction.getClip().name + " time"
          ] =
            currentAction.time /
            currentAction.getClip().duration;
          animation_state.animations = [
            {
              name: currentAction.getClip().name,
              loop: panelSettings.Loop
                ? true
                : "",
              progress:
                currentAction.time /
                currentAction.getClip().duration,
            },
          ];
        }

        stats.update();

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
